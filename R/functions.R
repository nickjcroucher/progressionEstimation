require(tidyverse)
require(magrittr)
require(rstan)
require(bridgesampling)
require(loo)
require(kableExtra)
require(xlsx)
require(cowplot)
require(ggrepel)

#' Generate data frame from input spreadsheet
#'
#' @param fn Name of spreadsheet file containing data
#' @param use_strain Boolean variable indicating whether the strain column should also be used for subtyping
#'
#' @return Data frame containing data extracted from spreadsheet
#' @export
#'
process_input_xlsx <- function(fn = "progression_estimation_input.xlsx", use_strain = FALSE) {
  max_col_num <- 7
  if (use_strain) {
    max_col_num <- 8
  }
  input_df <-
    xlsx::read.xlsx(
      file = fn,
      sheetIndex = 1,
      colIndex = 1:max_col_num,
      header = TRUE
    ) %>%
    dplyr::mutate(study = factor(study)) %>%
    dplyr::mutate(categorisation = factor(categorisation))
  return(input_df)
}

#' Generate model input from input data frame
#'
#' @param input_df Data frame containing details of case-carrier studies
#' @param subtype Name of column in input data frame used for subtyping information
#'
#' @return A list of lists used as an input to stan models
#' @export
#'
process_input_data <- function(input_df, subtype = "categorisation") {
  i_values <- as.integer(input_df$study)
  j_values <- as.integer(input_df[, which(colnames(input_df) == subtype)])
  c_ij <- input_df$carriage
  d_ij <- input_df$disease
  n_i <- input_df$carriage_samples
  N_i <- input_df$surveillance_population
  t_i <- input_df$time_interval
  progression_rate_data <- list(
    i_max = max(i_values),
    j_max = max(j_values),
    n_obs = length(c_ij),
    i_values = i_values,
    j_values = j_values,
    c_ij = c_ij,
    d_ij = d_ij,
    n_i = n_i,
    N_i = N_i,
    t_i = t_i
  )
  return(progression_rate_data)
}

#' Fit a progression rate model to case-carrier data
#'
#' @param input_data List of lists generated by `process_input_data`
#' @param type_specific Boolean specifying whether progression rates vary between types
#' @param location_adjustment Boolean specifying whether progression rates vary between locations
#' @param stat_model Whether progression to disease is "poisson" (Poisson process) or "negbin" (overdispersed negative binomial distribution)
#' @param strain_as_primary_type Whether strain should be used as the primary determinant of progression rate, and the other subtype used as the secondary determinant
#' @param strain_as_secondary_type Whether strain should be used as the secondary determinant of progression rate, and the other subtype used as the primary determinant
#' @param num_chains Number of MCMCs to be run for inference
#' @param num_iter Length of MCMCs
#' @param num_cores Number of threads used to calculate MCMCs
#' @param adapt_delta_value Target average acceptance probability of MCMCs (default = 0.8)
#'
#' @return A stanfit object
#' @export
#'
fit_progression_rate_model<-function(input_data,
                                     type_specific = TRUE,
                                     location_adjustment = TRUE,
                                     stat_model = "poisson",
                                     strain_as_primary_type = FALSE,
                                     strain_as_secondary_type = FALSE,
                                     num_chains = 4,
                                     num_iter = 1e4,
                                     num_cores = 1,
                                     adapt_delta_value = 0.8) {
  # Validate input
  model_suffix = match.arg(stat_model, c("poisson","negbin"), several.ok = FALSE)
  if ((strain_as_primary_type | strain_as_secondary_type) & !("strain" %in% colnames(input_data))) {
    stop("If strain to be used in typing, then needs to be in input data")
  }
  # Select model based on specifications
  model_prefix = "null"
  if (type_specific & location_adjustment) {
    model_prefix = "adjusted_type_specific"
  } else if (type_specific & !(location_adjustment)) {
    model_prefix = "type_specific"
  } else if (!(type_specific) & location_adjustment) {
    model_prefix = "adjusted_null"
  }
  model_name = paste0(model_prefix,'_',model_suffix)
  # Validate model name
  if (!(model_name %in% names(stanmodels))) {
    stop(paste(model_name,"not in list of valid model names"))
  }
  # Sample from model
  model_output<-
    rstan::sampling(stanmodels[[model_name]],
                    data = input_data,
                    iter = num_iter,
                    cores = num_cores,
                    chains = num_chains,
                    control = list(adapt_delta = adapt_delta_value)
    )
  # Return output
  return(model_output)
}

get_mean<-function(parameter,model) {
  return(rstan::summary(model,pars=c(parameter))$summary[,1])
}

get_upper<-function(parameter,model) {
  return(rstan::summary(model,pars=c(parameter))$summary[,8])
}

get_lower<-function(parameter,model) {
  return(rstan::summary(model,pars=c(parameter))$summary[,4])
}

#' Process the model output for downstream analysis
#'
#' @param input_df Data frame used as input to model fitting
#' @param model_output Stanfit object returned by model fitting
#' @param subtype Name of column used to define subtypes
#' @param strain_as_primary_type Whether strain was used as the primary determinant of progression rate, and the other subtype used as the secondary determinant
#' @param strain_as_secondary_type Whether strain was used as the secondary determinant of progression rate, and the other subtype used as the primary determinant
#'
#' @return A data frame
#' @export
#'
process_progression_rate_model_output<-function(input_df,
                                                model_output,
                                                subtype = "categorisation",
                                                strain_as_primary_type = FALSE,
                                                strain_as_secondary_type = FALSE) {
  # Extract progression rate estimates and intervals
  if (!strain_as_primary_type & !strain_as_secondary_type) {
    # Carriage prevalence estimates
    carriage_df <- data.frame(
      "rho" = get_mean("rho_ij",model_output),
      "rho_lower" = get_lower("rho_ij",model_output),
      "rho_upper" = get_upper("rho_ij",model_output)
    )
    # Variation by type
    nu_name = "nu"
    if ("nu_j" %in% model_output@model_pars) {
      nu_name = "nu_j"
    }
    subtype_parameters_df <- data.frame(
      "type" = levels(input_df[[subtype]]),
      "nu" = get_mean(nu_name,model_output),
      "nu_lower" = get_lower(nu_name,model_output),
      "nu_upper" = get_upper(nu_name,model_output)
    )
    # Variation by location
    scale_parameter <- 1
    if ("delta_i" %in% model_output@model_pars) {
      location_parameters <- data.frame(
        "study" = levels(input_df[["study"]]),
        "delta" = get_mean("delta_i",model_output),
        "delta_lower" = get_lower("delta_i",model_output),
        "delta_upper" = get_upper("delta_i",model_output)
      )
    } else {
      location_parameters <- data.frame(
        "study" = levels(input_df[["study"]]),
        "delta" = 1,
        "delta_lower" = 1,
        "delta_upper" = 1
      )
    }
    # Join information together
    updated_df <-
      input_df %>%
        dplyr::bind_cols(carriage_df) %>%
        dplyr::left_join(subtype_parameters_df, by = setNames("type",subtype)) %>%
        dplyr::left_join(location_parameters, by = c("study" = "study"))
  }
  # Extract predictions and intervals
  updated_df %<>%
    dplyr::mutate(carriage_prediction = get_mean("c_ij_pred",model_output)) %>%
    dplyr::mutate(carriage_prediction_lower = get_lower("c_ij_pred",model_output)) %>%
    dplyr::mutate(carriage_prediction_upper =  get_upper("c_ij_pred",model_output)) %>%
    dplyr::mutate(disease_prediction = get_mean("d_ij_pred",model_output)) %>%
    dplyr::mutate(disease_prediction_lower = get_lower("d_ij_pred",model_output)) %>%
    dplyr::mutate(disease_prediction_upper =  get_upper("d_ij_pred",model_output))
  return(updated_df)
}


#' Function for plotting the observed and predicted case-carrier counts
#'
#' @param model_output_df Data frame include input data and model fit output
#' @param n_label Number of top-ranked observations to label
#'
#' @return ggplot2 plot
#' @export
#'
plot_case_carrier_predictions <- function(model_output_df, n_label = 3) {
  if (!("carriage_prediction" %in% colnames(model_output_df))) {
    stop("Need to include model output in data frame for plotting")
  }
  carriage_labels <-
    model_output_df %>%
    dplyr::slice_max(carriage_prediction, n = n_label) %>%
    dplyr::select(categorisation, carriage, carriage_prediction)

  disease_labels <-
    model_output_df %>%
    dplyr::slice_max(disease_prediction, n = n_label) %>%
    dplyr::select(categorisation, disease, disease_prediction)

  carriage_plot <-
    ggplot(model_output_df,
           aes(x = carriage,
               y = carriage_prediction,
               ymin = carriage_prediction_lower,
               ymax = carriage_prediction_upper)) +
    geom_abline(slope = 1, intercept = 0, lty = 2, colour = "coral") +
    ylab("Number of carriage isolates predicted by model") +
    xlab("Number of observed carriage isolates") +
    theme_bw() +
    ggrepel::geom_text_repel(data = carriage_labels,
                             aes(x = carriage,
                                 y = carriage_prediction,
                                 label = categorisation),
                             alpha = 0.9,
                             force = 50,
                             inherit.aes = FALSE)

  disease_plot <-
    ggplot(model_output_df,
           aes(x = disease,
               y = disease_prediction,
               ymin = disease_prediction_lower,
               ymax = disease_prediction_upper)) +
    geom_abline(slope = 1, intercept = 0, lty = 2, colour = "coral") +
    ylab("Number of disease isolates predicted by model") +
    xlab("Number of observed disease isolates") +
    theme_bw() +
    ggrepel::geom_text_repel(data = disease_labels,
                             aes(x = disease,
                                 y = disease_prediction,
                                 label = categorisation),
                             alpha = 0.9,
                             force = 50,
                             inherit.aes = FALSE)
  # Add in function for colouring by location if appropriat
  if (model_output_df$study %>% dplyr::n_distinct() > 1) {
    carriage_plot <- carriage_plot +
      geom_point(aes(color = study)) +
      geom_errorbar(aes(color = study), alpha = 0.75) +
      theme(legend.position = "bottom")
    disease_plot <- disease_plot +
      geom_point(aes(color = study)) +
      geom_errorbar(aes(color = study), alpha = 0.75) +
      theme(legend.position = "bottom")
  } else {
    carriage_plot <- carriage_plot +
      geom_point(color = "blue") +
      geom_errorbar(color = "blue", alpha = 0.75)
    disease_plot <- disease_plot +
      geom_point(color = "blue") +
      geom_errorbar(color = "blue", alpha = 0.75)
  }

  cowplot::plot_grid(plotlist = list(carriage_plot, disease_plot))
}


#' Plot progression rate estimates
#'
#' @param model_output_df Data frame include input data and model fit output
#' @param unit_time String specifying the time unit for the y axis label
#' @param type_name Name of categorisation scheme for x axis label
#'
#' @return
#' @export
#'
plot_progression_rates <- function(model_output_df, unit_time = "unit time", type_name = "categorisation") {
  if (!("carriage_prediction" %in% colnames(model_output_df))) {
    stop("Need to include model output in data frame for plotting")
  }
  ggplot(model_output_df,
         aes(x = categorisation, y = nu, ymin = nu_lower, ymax = nu_upper)) +
    geom_point() +
    geom_errorbar() +
    ylab(paste0("Progression rate (disease per carrier per ",unit_time,")")) +
    xlab(type_name) +
    scale_y_continuous(trans ="log10") +
    theme_bw() +
    theme(axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.5))
}

#' Compare model fits using Bayes factors
#'
#' @param model_list List of stan fit objects
#' @param num_iter Number of iterations used for bridghe sampling
#'
#' @return Data frame containing Bayes factors
#' @export
#'
compare_model_fits_with_bf <- function(model_list, num_iter = 1e3) {
  model_names <- unlist(lapply(model_list, getElement, "model_name"))
  model_lml <- lapply(model_list,
                      bridgesampling::bridge_sampler,
                      maxiter = num_iter,
                      silent = TRUE)
  model_lml_values <- -1*unlist(lapply(model_lml, getElement, "logml"))
  lml_value_order <- order(model_lml_values)
  model_lml <- model_lml[lml_value_order]
  model_names <- model_names[lml_value_order]
  bf_values <- c()
  for (x in 1:length(model_names)) {
    bf_values <- c(bf_values,
                   bridgesampling::bf(model_lml[[x]], model_lml[[1]], log = TRUE)$bf
    )
  }
  bf_df <- data.frame(
    "Model" = model_names,
    "log_Bayes_factor" = bf_values
  )
  return(bf_df)
}


run_loo_analysis <- function(model_fit) {
  ll <- loo::extract_log_lik(model_fit, merge_chains = F)
  r_eff <- loo::relative_eff(ll)
  loo <- loo(ll, r_eff = r_eff, save_psis = TRUE)
  return(loo)
}

#' Compare model fits using leave-one-out cross-validation
#'
#' @param model_list List of stan fit objects
#'
#' @return Data frame containing cross-validation values
#' @export
#'
compare_model_fits_with_loo <- function(model_list) {
  model_loo <- lapply(model_list, run_loo_analysis)
  loo_comparisons <- loo::loo_compare(model_loo)
  model_names <- unlist(lapply(model_list, getElement, "model_name"))
  rownames(loo_comparisons) <- model_names[order(rownames(loo_comparisons))]
  return(loo_comparisons)
}

#' Combine input data frames for meta-analyses
#'
#' @param new_df Data frame with new studies
#' @param old_df Data frame with old studies
#'
#' @return Combined data frame
#' @export
#'
combine_with_existing_datasets <- function(new_df, old_df) {
  new_studies <-
    new_df %>% dplyr::select(study) %>% dplyr::distinct() %>% dplyr::pull()
  old_studies <-
    old_df %>% dplyr::select(study) %>% dplyr::distinct() %>% dplyr::pull()
  if (new_studies %in% old_studies) {
    stop("Names of studies in new data must not be present in old studies")
  }
  combined_df <- dplyr::bind_rows(old_df, new_df)
  return(combined_df)
}

#' Plot study scale factors
#'
#' @param model_output_df Data frame include input data and model fit output
#'
#' @return ggplot2 object
#' @export
#'
plot_study_scale_factors <- function(model_output_df) {
  if (!("carriage_prediction" %in% colnames(model_output_df))) {
    stop("Need to include model output in data frame for plotting")
  }
  ggplot(model_output_df,
         aes(x = study, y = delta, ymin = delta_lower, ymax = delta_upper)) +
    geom_point() +
    geom_errorbar() +
    ylab(paste0("Study scale factor")) +
    xlab("Study") +
    scale_y_continuous(trans = "log10") +
    theme_bw() +
    theme(axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.5))
}
